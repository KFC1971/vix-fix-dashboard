--- Page 1 ---
Quantitative  Mean  Reversion:  A  
Comprehensive
 
Framework
 
for
 
the
 
CM
 
Williams
 
Vix
 
Fix
 
Strategy
 Executive  Summary  
The  pursuit  of  identifying  market  inflection  points—specifically  market  bottoms—is  a  central  
theme
 
in
 
quantitative
 
finance.
 
While
 
trend-following
 
strategies
 
seek
 
to
 
exploit
 
the
 
persistence
 
of
 
price
 
directionality
 
(momentum),
 
mean-reversion
 
strategies
 
rely
 
on
 
the
 
statistical
 
property
 
that
 
asset
 
prices
 
and
 
volatility
 
tend
 
to
 
oscillate
 
around
 
a
 
long-term
 
equilibrium.
 
When
 
elasticity
 
is
 
stretched
 
to
 
a
 
breaking
 
point,
 
represented
 
by
 
extreme
 
fear
 
or
 
panic
 
selling,
 
the
 
probability
 
of
 
a
 
snap-back
 
or
 
"reversion"
 
increases
 
significantly.
 
This  research  report  provides  an  exhaustive  technical  and  theoretical  analysis  of  the  CM  
Williams
 
Vix
 
Fix
 
strategy,
 
a
 
synthetic
 
volatility
 
indicator
 
designed
 
to
 
replicate
 
the
 
mechanics
 
of
 
the
 
CBOE
 
Volatility
 
Index
 
(VIX)
 
for
 
individual
 
assets.
 
Unlike
 
the
 
VIX,
 
which
 
is
 
derived
 
from
 
implied
 
volatility
 
in
 
options
 
chains,
 
the
 
Williams
 
Vix
 
Fix
 
is
 
calculated
 
purely
 
from
 
Open-High-Low-Close
 
(OHLC)
 
price
 
data,
 
democratizing
 
access
 
to
 
institutional-grade
 
volatility
 
metrics.
 
This  document  serves  as  a  complete  engineering  specification  and  theoretical  treatise  for  
constructing
 
a
 
Python-based
 
scanning
 
engine.
 
The
 
system
 
is
 
designed
 
to
 
scan
 
the
 
top
 
100
 
most
 
liquid
 
S&P
 
500
 
stocks,
 
employing
 
a
 
"Time
 
Machine"
 
architecture
 
to
 
facilitate
 
both
 
real-time
 
signal
 
generation
 
and
 
historical
 
validation.
 
The
 
strategy
 
integrates
 
a
 
regime
 
filter
 
(200-day
 
Simple
 
Moving
 
Average)
 
to
 
ensure
 
trades
 
are
 
taken
 
in
 
the
 
direction
 
of
 
the
 
secular
 
trend,
 
and
 
a
 
1-day
 
lag
 
mechanism
 
to
 
confirm
 
mean
 
reversion
 
before
 
capital
 
deployment.
 
The  following  sections  detail  the  mathematical  derivation  of  the  indicators,  the  software  
architecture
 
required
 
to
 
handle
 
financial
 
time-series
 
data
 
using
 
yfinance
 
and
 
pandas,
 
and
 
the
 
rigorous
 
backtesting
 
methodologies
 
necessary
 
to
 
validate
 
the
 
strategy's
 
predictive
 
power.
 
Part  I:  Theoretical  Framework  of  Volatility  and  Mean  
Reversion
 1.1  The  Asymmetry  of  Market  Psychology  
To  comprehend  the  efficacy  of  the  Williams  Vix  Fix,  one  must  first  appreciate  the  asymmetrical  
nature
 
of
 
market
 
volatility.
 
Financial
 
markets
 
are
 
driven
 
by
 
human
 
psychology,
 
oscillating
 
--- Page 2 ---
between  greed  and  fear.  However,  these  emotions  do  not  manifest  symmetrically  in  price  
action.
 
Greed
 
is
 
often
 
a
 
slow,
 
compounding
 
process;
 
bull
 
markets
 
tend
 
to
 
"climb
 
a
 
wall
 
of
 
worry,"
 
characterized
 
by
 
lower
 
realized
 
volatility
 
and
 
steady,
 
incremental
 
gains.
 
Conversely,  fear  is  an  acute,  visceral  reaction.  Market  crashes  and  corrections  are  typically  
sharp,
 
violent,
 
and
 
rapid.
 
This
 
phenomenon
 
is
 
empirically
 
observable
 
in
 
the
 
CBOE
 
Volatility
 
Index
 
(VIX),
 
often
 
referred
 
to
 
as
 
the
 
"fear
 
gauge."
 
The
 
VIX
 
spikes
 
aggressively
 
during
 
market
 
downturns
 
and
 
decays
 
slowly
 
during
 
recoveries.
 
This
 
inverse
 
correlation
 
between
 
price
 
and
 
volatility
 
is
 
the
 
foundational
 
axiom
 
of
 
the
 
CM
 
Williams
 
Vix
 
Fix
 
strategy.
2  
1.2  The  Synthetic  VIX:  Mathematical  Derivation  
The  CBOE  VIX  is  calculated  using  a  complex  formula  based  on  the  bid-ask  spreads  of  S&P  
500
 
index
 
options.
 
It
 
measures
 
implied
 
volatility—the
 
market's
 
expectation
 
of
 
future
 
variance.
 
However,
 
calculating
 
a
 
"VIX"
 
for
 
every
 
individual
 
stock
 
(e.g.,
 
Apple,
 
Microsoft,
 
Ford)
 
is
 
computationally
 
difficult
 
and
 
often
 
impossible
 
due
 
to
 
the
 
lack
 
of
 
liquid
 
options
 
chains
 
for
 
all
 
maturities.
 
Larry  Williams,  a  renowned  technical  analyst,  proposed  a  synthetic  proxy  that  mimics  the  VIX's  
behavior
 
using
 
only
 
price
 
data.
 
His
 
observation
 
was
 
simple
 
yet
 
profound:
 
volatility
 
can
 
be
 
approximated
 
by
 
the
 
relationship
 
between
 
the
 
current
 
period's
 
low
 
and
 
the
 
recent
 
period's
 
highest
 
close.
 
The  formula  for  the  Williams  Vix  Fix  (WVF)  is  defined  as:  
 $$WVF_t  =  \frac{\text{Highest}(\text{Close},  n)  -  \text{Low}_t}{\text{Highest}(\text{Close},  n)}  
\times
 
100$$
 Where:  ●  $WVF_t$  is  the  Williams  Vix  Fix  value  at  time  $t$.  ●  $\text{Highest}(\text{Close},  n)$  is  the  highest  closing  price  over  the  lookback  window  
$n$.
 
The
 
standard
 
default
 
is
 
22
 
periods,
 
corresponding
 
to
 
approximately
 
one
 
trading
 
month.
3  
●  $\text{Low}_t$  is  the  lowest  price  of  the  current  bar  (candle).  
Mathematical  Implications:  When  the  market  is  making  new  highs,  the  numerator  approaches  zero  because  the  current  
low
 
is
 
very
 
close
 
to
 
the
 
recent
 
highest
 
close.
 
Consequently,
 
the
 
WVF
 
reading
 
is
 
low—indicating
 
complacency
 
or
 
stability.
 However,  during  a  market  crash,  the  "Highest  Close"  remains  fixed  at  the  recent  peak,  while  
the
 
"Low"
 
drops
 
precipitously.
 
This
 
causes
 
the
 
numerator
 
to
 
expand
 
rapidly,
 
resulting
 
in
 
a
 
spike
 
in
 
the
 
WVF
 
value.
 
This
 
behavior
 
mathematically
 
replicates
 
the
 
VIX:
 
it
 
is
 
low
 
at
 
market
 
tops
 
and
 
spikes
 
at
 
market
 
bottoms.4
 
--- Page 3 ---
1.3  Statistical  Extremes  via  Bollinger  Bands  
A  raw  WVF  value  is  difficult  to  trade  in  isolation.  A  WVF  reading  of  "20"  might  be  extremely  
high
 
for
 
a
 
low-volatility
 
utility
 
stock
 
like
 
Duke
 
Energy
 
but
 
completely
 
normal
 
for
 
a
 
high-beta
 
stock
 
like
 
Tesla.
 
To
 
standardize
 
the
 
signal
 
across
 
diverse
 
assets,
 
Chris
 
Moody
 
(CM)
 
applied
 
Bollinger
 
Bands
 
to
 
the
 
WVF
 
indicator
 
itself.
6  
Bollinger  Bands  consist  of  a  Simple  Moving  Average  (SMA)  and  two  standard  deviation  lines  
plotted
 
above
 
and
 
below
 
it.
 ●  WVF  SMA:  A  20-period  moving  average  of  the  WVF  values.  ●  Upper  Band:  $SMA  +  (2  \times  \sigma)$.  ●  Lower  Band:  $SMA  -  (2  \times  \sigma)$.  
By  generating  a  signal  only  when  the  WVF  crosses  above  the  Upper  Bollinger  Band,  the  
strategy
 
identifies
 
statistical
 
outliers
.
 
It
 
signals
 
that
 
the
 
current
 
"fear"
 
(volatility)
 
is
 
not
 
just
 
high
 
in
 
absolute
 
terms,
 
but
 
is
 
historically
 
high
 
relative
 
to
 
the
 
asset's
 
recent
 
behavior
 
(2
 
standard
 
deviations
 
implies
 
the
 
event
 
is
 
in
 
the
 
top
 
~2.5%
 
of
 
occurrences,
 
assuming
 
a
 
normal
 
distribution).
 
1.4  The  Regime  Filter:  The  200-Day  SMA  
Mean  reversion  strategies  are  inherently  dangerous  because  they  involve  "catching  a  falling  
knife"—buying
 
an
 
asset
 
that
 
is
 
rapidly
 
depreciating.
 
In
 
a
 
secular
 
bear
 
market
 
(e.g.,
 
the
 
2008
 
Financial
 
Crisis
 
or
 
the
 
2000
 
Dot-Com
 
Bubble),
 
an
 
asset
 
can
 
remain
 
"oversold"
 
for
 
months,
 
causing
 
oscillators
 
to
 
give
 
repeated
 
false
 
buy
 
signals
 
as
 
the
 
price
 
grinds
 
toward
 
zero.
 
To  mitigate  this  catastrophic  risk,  the  strategy  employs  a  regime  filter:  Price  >  200-day  SMA.  The  200-day  Simple  Moving  Average  is  a  widely  respected  proxy  for  the  long-term  trend.  By  
requiring
 
the
 
price
 
to
 
be
 
above
 
this
 
level,
 
the
 
strategy
 
filters
 
for
 
pullbacks
 
within
 
a
 
primary
 
uptrend.
 
We
 
are
 
not
 
trying
 
to
 
catch
 
the
 
bottom
 
of
 
a
 
crash;
 
we
 
are
 
trying
 
to
 
catch
 
a
 
cyclical
 
dip
 
in
 
a
 
structurally
 
sound
 
market.
 
This
 
distinction
 
drastically
 
improves
 
the
 
win
 
rate
 
and
 
reduces
 
the
 
severity
 
of
 
drawdowns.8
 
Part  II:  Data  Architecture  and  Engineering  
Implementing  this  strategy  in  Python  requires  a  robust  data  pipeline  capable  of  handling  large  
datasets,
 
adjusting
 
for
 
corporate
 
actions,
 
and
 
simulating
 
historical
 
states
 
("Time
 
Machine"
 
mode).
 
2.1  The  Python  Ecosystem:  yfinance  and  pandas  
The  implementation  leverages  two  primary  libraries:  1.  yfinance:  A  popular  open-source  library  that  scrapes  data  from  Yahoo  Finance.  It  is  
--- Page 4 ---
chosen  for  its  ease  of  use  and  zero  cost,  though  it  comes  with  limitations  such  as  rate  
limiting
 
and
 
lack
 
of
 
official
 
support.
 
Crucially,
 
yfinance
 
provides
 
"Adjusted
 
Close"
 
data,
 
which
 
retrospectively
 
adjusts
 
prices
 
for
 
dividends
 
and
 
stock
 
splits.
 
For
 
technical
 
indicators
 
like
 
the
 
200
 
SMA,
 
using
 
unadjusted
 
data
 
would
 
introduce
 
massive
 
artifacts
 
(e.g.,
 
a
 
4-for-1
 
split
 
looks
 
like
 
a
 
75%
 
price
 
crash).
9  
2.  pandas:  The  backbone  of  financial  data  analysis  in  Python.  pandas  allows  for  vectorized  
operations,
 
meaning
 
calculations
 
can
 
be
 
performed
 
on
 
entire
 
columns
 
of
 
data
 
simultaneously
 
rather
 
than
 
iterating
 
row-by-row.
 
This
 
is
 
essential
 
for
 
performance
 
when
 
scanning
 
hundreds
 
of
 
tickers
 
over
 
thousands
 
of
 
days.
11  
2.2  S&P  500  Constituent  Selection  and  Liquidity  Filtering  
The  S&P  500  is  not  a  static  list;  it  changes  quarterly  as  companies  are  added  or  removed  
based
 
on
 
market
 
cap
 
and
 
profitability.
 ●  Data  Source:  Since  yfinance  does  not  provide  an  index  constituent  endpoint,  we  must  
scrape
 
the
 
current
 
list
 
from
 
Wikipedia
 
using
 
pd.read_html.
12  
●  Survivorship  Bias  Warning:  Using  the  current  S&P  500  list  to  test  historical  dates  (e.g.,  
2015)
 
introduces
 
survivorship
 
bias.
 
We
 
are
 
testing
 
companies
 
that
 
were
 
successful
 
enough
 
to
 
remain
 
or
 
enter
 
the
 
index
 
by
 
today,
 
excluding
 
those
 
that
 
failed.
 
While
 
"Point-in-Time"
 
databases
 
(like
 
CRSP)
 
solve
 
this,
 
they
 
are
 
expensive.
 
For
 
this
 
implementation,
 
we
 
accept
 
the
 
bias
 
but
 
note
 
it
 
as
 
a
 
limitation.
14  
Volume  Filtering:  The  strategy  targets  the  "Top  100  stocks  by  daily  volume."  Liquidity  is  a  fractal  property;  
technical
 
analysis
 
tends
 
to
 
be
 
more
 
reliable
 
in
 
highly
 
liquid
 
assets
 
where
 
price
 
discovery
 
is
 
efficient
 
and
 
manipulation
 
is
 
difficult.
 
Low-volume
 
stocks
 
are
 
prone
 
to
 
"gapping"
 
and
 
slippage,
 
which
 
can
 
invalidate
 
the
 
theoretical
 
entry
 
and
 
exit
 
prices
 
of
 
a
 
backtest.
 We  calculate  the  rolling  30-day  average  volume  (dollar  volume  or  share  volume)  to  rank  the  
constituents,
 
ensuring
 
we
 
select
 
stocks
 
that
 
consistently
 
trade
 
with
 
high
 
liquidity,
 
rather
 
than
 
those
 
that
 
just
 
had
 
a
 
single
 
high-volume
 
spike.15
 
Part  III:  Strategy  Logic  and  The  "Time  Machine"  
The  core  logic  of  the  scanner  is  designed  to  function  in  two  modes:  Real-Time  Scan  (Today)  
and
 
Historical
 
Validation
 
(Past
 
Date).
 
This
 
dual
 
functionality
 
requires
 
careful
 
handling
 
of
 
datetime
 
indexing
 
to
 
avoid
 
"look-ahead
 
bias"—the
 
cardinal
 
sin
 
of
 
quantitative
 
trading
 
where
 
the
 
model
 
accidentally
 
uses
 
future
 
data
 
to
 
make
 
a
 
past
 
decision.
 
3.1  The  1-Day  Confirmation  Lag  
The  user  query  specifies  a  "1-day  confirmation  lag."  This  is  a  sophisticated  requirement  that  
aligns
 
with
 
professional
 
trading
 
setups.
 
--- Page 5 ---
●  The  Setup  (Day  $T-1$):  The  WVF  closes  above  the  Upper  Bollinger  Band.  This  indicates  
the
 
peak
 
of
 
the
 
panic.
 
However,
 
buying
 
immediately
 
at
 
the
 
close
 
of
 
a
 
panic
 
day
 
is
 
risky;
 
the
 
market
 
could
 
gap
 
down
 
the
 
next
 
morning.
 ●  The  Confirmation  (Day  $T$):  The  trader  waits  for  the  close  of  the  next  trading  day.  If  
the
 
signal
 
(setup)
 
remains
 
valid
 
and
 
price
 
action
 
stabilizes,
 
the
 
trade
 
is
 
taken.
 ●  Software  Logic:  When  the  user  asks  to  scan  for  a  date  "2023-11-25",  the  scanner  looks  
for
 
the
 
Signal
 
(Spike)
 
to
 
have
 
occurred
 
on
 
"2023-11-24".
 
The
 
report
 
on
 
the
 
25th
 
confirms
 
that
 
the
 
setup
 
from
 
the
 
24th
 
is
 
actionable.
 ●  Visualizing  the  Logic:  1.  Calculate  Indicators:  For  the  entire  history.  2.  Shift  Logic:  Create  a  boolean  mask  where  Signal  =  (Close  >  SMA200)  &  (WVF  >  
UpperBB).
 3.  Lag  Check:  To  find  valid  trades  for  TargetDate,  we  check  if  Signal  was  True  at  
TargetDate
 
-
 
1
 
Day.
 
3.2  Post-Signal  Validation  (The  5-Day  Horizon)  
To  verify  the  strategy,  the  system  calculates  the  performance  of  the  trade  after  the  signal.  ●  Entry  Price:  Assumed  to  be  the  Open  of  the  scan  date  ($T$).  This  simulates  seeing  the  
signal
 
from
 
the
 
previous
 
close
 
($T-1$)
 
and
 
entering
 
immediately
 
at
 
market
 
open.
 ●  Exit  Price:  The  Close  of  $T+5$  (one  trading  week  later).  ●  Metric:  (Exit  -  Entry)  /  Entry  *  100. This  5-day  window  is  chosen  because  VIX-based  mean  reversion  is  typically  a  short-term  
phenomenon.
 
If
 
the
 
"elastic
 
band"
 
snaps
 
back,
 
it
 
usually
 
happens
 
within
 
3
 
to
 
5
 
days.
 
If
 
the
 
trade
 
is
 
not
 
profitable
 
after
 
a
 
week,
 
the
 
"fear"
 
likely
 
indicated
 
a
 
genuine
 
fundamental
 
deterioration
 
rather
 
than
 
a
 
temporary
 
panic.16
 
Part  IV:  Python  Implementation  
The  following  section  presents  the  complete,  annotated  Python  code.  The  code  is  structured  
as
 
a
 
class-based
 
system
 
for
 
modularity
 
and
 
maintainability.
 
4.1  Dependency  Setup  
 
Python  
  import yfinance  as yf  import pandas  as pd  import numpy  as np  
--- Page 6 ---
import datetime  import requests  import warnings  
 #  Suppress  warnings  for  cleaner  output  in  a  report  context 
warnings.filterwarnings('ignore')  
 #  Display  settings  for  Pandas  to  ensure  tables  render  nicely  in  logs 
pd.set_option('display.max_columns',  None)  
pd.set_option('display.width',  1000)  
pd.set_option('display.float_format',  lambda x:  '%.2f' %  x)  
 
4.2  The  Scanner  Class  Structure  
The  CMWilliamsVixFixScanner  class  encapsulates  the  entire  workflow:  fetching  tickers,  
downloading
 
data,
 
calculating
 
complex
 
vector
 
indicators,
 
and
 
executing
 
the
 
"Time
 
Machine"
 
logic.
 
 
Python  
  class CMWilliamsVixFixScanner: 
    def __init__(self,  lookback_period=22,  bb_length=20,  bb_std=2.0,  sma_filter=200,  
top_n_volume=100): 
        """  
        
Initializes
 
the
 
scanner
 
with
 
strategy
 
parameters.
 
        
 
        
Args:
 
            
lookback_period
 
(int):
 
Lookback
 
for
 
WVF
 
calculation
 
(Standard:
 
22).
 
            
bb_length
 
(int):
 
Bollinger
 
Band
 
length
 
(Standard:
 
20).
 
            
bb_std
 
(float):
 
Bollinger
 
Band
 
standard
 
deviation
 
(Standard:
 
2.0).
 
            
sma_filter
 
(int):
 
Simple
 
Moving
 
Average
 
trend
 
filter
 
(Standard:
 
200).
 
            
top_n_volume
 
(int):
 
Number
 
of
 
top
 
liquid
 
stocks
 
to
 
scan
 
(Standard:
 
100).
 
        
""" 
        
self.lookback_period
 
=
 
lookback_period
 
        
self.bb_length
 
=
 
bb_length
 
        
self.bb_std
 
=
 
bb_std
 
        
self.sma_filter
 
=
 
sma_filter
 
        
self.top_n_volume
 
=
 
top_n_volume
 
        
self.tickers
 
=
 
        
self.data
 
=
 None 
        
self.results
 
=
 
--- Page 7 ---
 
    def get_sp500_tickers(self): 
        """  
        
Scrapes
 
the
 
list
 
of
 
S&P
 
500
 
tickers
 
from
 
Wikipedia.
 
        
Handles
 
ticker
 
symbol
 
conversion
 
(e.g.,
 
BRK.B
 
->
 
BRK-B)
 
for
 
yfinance
 
compatibility.
 
        
""" 
        
print("[INFO]  Scraping  S&P  500  constituents  from  Wikipedia...")  
        
url
 
=
 'https://en.wikipedia.org/wiki/List_of_S%26P_500_companies' 
        try:  
            
tables
 
=
 
pd.read_html(url)
 
            
df_tickers
 
=
 
tables
 
            #  Replace  dots  with  dashes  for  YFinance  compatibility  (e.g.,  BRK.B  ->  BRK-B) 
            
self.tickers
 
=.tolist()]
 
            
print(f"  Retrieved  {len(self.tickers)} tickers.")  
        except Exception  as e:  
            
print(f"  Failed  to  retrieve  tickers:  {e}")  
            
self.tickers
 
=
 
 
    def fetch_data(self,  target_date_str): 
        """  
        
Downloads
 
historical
 
data
 
for
 
all
 
tickers.
 
        
Filters
 
for
 
the
 
Top
 
100
 
by
 
volume
 
relative
 
to
 
the
 
target
 
date.
 
        
""" 
        
print("[INFO]  Configuring  Time  Machine  Data  Pipeline...")  
        
 
        #  Parse  target  date 
        if target_date_str.lower()  ==  'today':  
            
target_date
 
=
 
datetime.datetime.now().date()
 
        else:  
            
target_date
 
=
 
datetime.datetime.strptime(target_date_str,
 "%Y-%m-%d").date()  
 
        #  Define  data  range: 
        #  Start:  Need  200  days  prior  for  SMA  +  buffer.  Safe  to  go  400  days  back. 
        #  End:  Need  5-10  days  AFTER  target  date  for  validation  metrics. 
        
start_date
 
=
 
target_date
 
-
 
datetime.timedelta(days=400)  
        
end_date
 
=
 
target_date
 
+
 
datetime.timedelta(days=15)  
        
 
        #  Cap  end_date  at  today  to  prevent  YFinance  errors 
        if end_date  >  datetime.datetime.now().date():  
            
end_date
 
=
 
datetime.datetime.now().date()
 
 
        
print(f"[INFO]  Downloading  bulk  data  from  {start_date} to  {end_date}.  Please  wait...")  
        
 
--- Page 8 ---
        #  Bulk  download  using  threads 
        #  group_by='ticker'  creates  a  MultiIndex  DataFrame 
        
raw_data
 
=
 
yf.download(self.tickers,
 
start=start_date,
 
end=end_date,
 
 
                               
group_by='ticker',  auto_adjust=True,  threads=True,  progress=False)  
        
 
        #  ---  VOLUME  FILTERING  LOGIC  --- 
        #  We  need  to  rank  stocks  by  their  volume  *prior*  to  the  target  date. 
        #  This  prevents  look-ahead  bias  (e.g.,  filtering  by  volume  in  2024  for  a  2020  scan). 
        
 
        
print(f"[INFO]  Calculating  liquidity  rankings  for  {target_date}...")  
        
avg_volumes
 
=
 
        
 
        for ticker  in self.tickers:  
            try:  
                #  Extract  dataframe  for  specific  ticker 
                
df
 
=
 
raw_data[ticker]
 
                
 
                #  Filter  data  strictly  before  target  date 
                
history
 
=
 
df[df.index.date
 
<
 
target_date]
 
                
 
                if len(history)  <  50:  
                    continue #  Skip  if  insufficient  history 
                
 
                #  Calculate  30-day  average  volume 
                
avg_vol
 
=
 
history['Volume'].tail(30).mean()  
                
avg_volumes.append((ticker,
 
avg_vol))
 
            except KeyError:  
                continue 
 
        #  Sort  by  volume  descending  and  slice  top  N 
        
avg_volumes.sort(key=lambda x:  x[1],  reverse=True)  
        
top_tickers
 
=
 
[x
 for x  in avg_volumes[:self.top_n_volume]]  
        
 
        
print(f"[INFO]  Filtered  down  to  Top  {self.top_n_volume} liquid  stocks.")  
        
print(f"        Top  3:  {top_tickers[:3]}")  
        
 
        #  Store  only  the  relevant  data  in  memory 
        
self.data
 
=
 
raw_data[top_tickers]
 
        
self.tickers
 
=
 
top_tickers
 
        
self.target_date
 
=
 
target_date
 
 
    def calculate_indicators(self): 
        """  
--- Page 9 ---
        Performs  vectorized  calculation  of  SMA,  WVF,  and  Bollinger  Bands.  
        
""" 
        
print("[INFO]  Computing  Technical  Indicators  (SMA200,  WVF,  BB)...")  
        
 
        #  We  process  each  ticker  individually  to  handle  the  MultiIndex  structure  cleanly 
        
processed_frames
 
=
 
{}
 
        
 
        for ticker  in self.tickers:  
            try:  
                
df
 
=
 
self.data[ticker].copy()
 
                
 
                #  Check  if  dataframe  is  empty  or  has  too  many  NaNs 
                if df.empty:   
                    continue 
                
 
                #  1.  200  SMA  (Trend  Filter) 
                
df
 
=
 
df['Close'].rolling(window=self.sma_filter).mean()  
                
 
                #  2.  Williams  Vix  Fix  (WVF) 
                #  Formula:  (Highest(Close,  22)  -  Low)  /  Highest(Close,  22)  *  100 
                
df['Highest_Close']  =  df['Close'].rolling(window=self.lookback_period).max()  
                
df
 
=
 
((df['Highest_Close']  -  df['Low'])  /  df['Highest_Close'])  *  100 
                
 
                #  3.  Bollinger  Bands  of  WVF 
                #  Calculated  on  the  WVF  series,  not  Price 
                
df
 
=
 
df.rolling(window=self.bb_length).mean()
 
                
df
 
=
 
df.rolling(window=self.bb_length).std()
 
                
 
                
df
 
=
 
df
 
+
 
(self.bb_std
 
*
 
df)
 
                #  Lower  BB  is  usually  not  needed  for  this  specific  "Bottom  Finding"  strategy,  but  calculated  
for
 
completeness 
                
df
 
=
 
df
 
-
 
(self.bb_std
 
*
 
df)
 
                
 
                
processed_frames[ticker]
 
=
 
df
 
                
 
            except Exception  as e:  
                continue 
                
 
        
self.processed_data
 
=
 
processed_frames
 
 
    def run_scan(self): 
        """  
        
Executes
 
the
 
logic
 
check
 
for
 
the
 
Target
 
Date
 
with
 
1-Day
 
Lag.
 
--- Page 10 ---
        """ 
        
print(f"[INFO]  Scanning  for  signals  on  Target  Date:  {self.target_date}")  
        
results
 
=
 
        
 
        for ticker,  df  in self.processed_data.items():  
            #  Find  the  index  location  of  the  target  date 
            #  usage  of  get_loc  with  method='pad'  ensures  we  find  the  closest  previous  trading  day 
            #  if  the  target  date  falls  on  a  weekend/holiday. 
            try:  
                
target_idx
 
=
 
df.index.get_indexer(,
 
method='pad')  
                
 
                if target_idx  <  self.sma_filter:  
                    continue #  Not  enough  data 
                
 
                #  Define  Logic  Indices 
                #  We  need  the  signal  to  have  fired  on  T-1  (Yesterday  relative  to  scan  date) 
                #  We  assume  scan  runs  at  Close  of  T,  or  Open  of  T+1. 
                
 
                
idx_signal
 
=
 
target_idx
 
-
 1 #  The  day  the  "Green  Bar"  /  Spike  happened 
                
idx_scan
 
=
 
target_idx
       #  The  day  we  are  confirming/acting 
                
 
                
row_signal
 
=
 
df.iloc[idx_signal]
 
                
row_scan
 
=
 
df.iloc[idx_scan]
 
                
 
                #  LOGIC  GATES 
                #  1.  Trend  Filter:  Price  must  be  >  200  SMA  *at  the  time  of  signal* 
                
trend_condition
 
=
 
row_signal['Close']  >  row_signal  
                
 
                #  2.  Volatility  Trigger:  WVF  >  Upper  Bollinger  Band 
                
wvf_condition
 
=
 
row_signal
 
>
 
row_signal
 
                
 
                if trend_condition  and wvf_condition:  
                    
 
                    #  3.  Validation  (5-Day  Future  Performance) 
                    #  We  enter  at  Open  of  Scan  Day  (T)  and  hold  until  Close  of  T+5 
                    
perf_metric
 
=
 
np.nan
 
                    
outcome_str
 
=
 "Real-Time  (Wait)" 
                    
 
                    #  Check  if  future  data  exists 
                    if target_idx  +  5 <  len(df):  
                        
entry_price
 
=
 
row_scan['Open']  
                        
exit_price
 
=
 
df.iloc[target_idx
 
+
 5]['Close']  
                        
 
--- Page 11 ---
                        if entry_price  >  0:  
                            
perf_metric
 
=
 
((exit_price
 
-
 
entry_price)
 
/
 
entry_price)
 
*
 100 
                            
outcome_str
 
=
 f"{perf_metric:.2f}%" 
                    
 
                    
results.append({
 
                        'Ticker':  ticker,  
                        'Signal_Date':  df.index[idx_signal].date(),  
                        'Scan_Date':  df.index[idx_scan].date(),  
                        'Price_at_Signal':  row_signal['Close'],  
                        'SMA_200':  row_signal,  
                        'WVF_Value':  row_signal,  
                        'WVF_Upper_BB':  row_signal,  
                        '5_Day_Return':  outcome_str,  
                        '_raw_return':  perf_metric  #  Hidden  column  for  stats  calculation 
                    
})
 
                    
 
            except IndexError:  
                continue 
            except KeyError:  
                continue 
 
        
self.results
 
=
 
pd.DataFrame(results)
 
        return self.results  
 
    def generate_report(self): 
        """  
        
Outputs
 
the
 
results
 
in
 
a
 
clean
 
table
 
format.
 
        
""" 
        if self.results.empty:  
            
print("\n  No  setups  found  for  this  date  matching  criteria.")  
            return 
 
        #  Select  columns  for  display 
        
display_cols
 
=
 
        
 
        
print(f"\n{'='*60}")  
        
print(f"SCAN  REPORT:  CM  Williams  Vix  Fix")  
        
print(f"Target  Scan  Date:  {self.target_date}")  
        
print(f"{'='*60}")  
        
print(self.results[display_cols].to_markdown(index=False,  floatfmt=".2f"))  
        
 
        #  Aggregate  Statistics  for  Validation 
        #  Only  calculate  if  we  have  historical  data  (not  real-time) 
--- Page 12 ---
        valid_returns  =  self.results['_raw_return'].dropna()  
        
 
        if not valid_returns.empty:  
            
avg_ret
 
=
 
valid_returns.mean()
 
            
win_rate
 
=
 
(valid_returns
 
>
 0).sum()  /  len(valid_returns)  *  100 
            
 
            
print(f"\n---  Validation  Metrics  (5-Day  Hold)  ---")  
            
print(f"Total  Signals:  {len(valid_returns)}")  
            
print(f"Average  Return:  {avg_ret:.2f}%")  
            
print(f"Win  Rate:        {win_rate:.2f}%")  
            
print(f"{'='*60}")  
 
4.3  Execution  Script  
To  run  the  scanner,  the  user  simply  instantiates  the  class  and  calls  the  methods  in  sequence.  
 
Python  
  #  ---  MAIN  EXECUTION  BLOCK  --- if __name__  ==  "__main__":  
    
 
    #  1.  Initialize 
    
scanner
 
=
 
CMWilliamsVixFixScanner()
 
    
 
    #  2.  Get  Tickers 
    
scanner.get_sp500_tickers()
 
    
 
    #  3.  User  Input  (Simulation) 
    #  user_input_date  =  input("Enter  Scan  Date  (YYYY-MM-DD)  or  'today':  ") 
    
user_input_date
 
=
 '2023-10-27' #  Example:  Market  bottom  in  Oct  2023 
    
 
    #  4.  Fetch  &  Process 
    
scanner.fetch_data(user_input_date)
 
    
scanner.calculate_indicators()
 
    
 
    #  5.  Run  Scan  &  Report 
    
scanner.run_scan()
 
    
scanner.generate_report()
 
 
--- Page 13 ---
Part  V:  Analysis  of  Strategy  Mechanics  and  Nuances  5.1  The  "Green  Bar"  Phenomenon  vs.  1-Day  Lag  
The  research  snippets  
2
 frequently  mention  a  "Green  Bar."  In  the  original  TradingView  script  by  
Chris
 
Moody,
 
the
 
histogram
 
bars
 
change
 
color
 
based
 
on
 
specific
 
criteria.
 
A
 
"Gray"
 
bar
 
indicates
 
normal
 
volatility.
 
A
 
"Green"
 
bar
 
indicates
 
the
 
WVF
 
has
 
crossed
 
above
 
the
 
Upper
 
Bollinger
 
Band
 
(High
 
Volatility)
 
but
 
might
 
be
 
starting
 
to
 
recede.
 
The  1-Day  Lag  implemented  in  our  Python  script  effectively  acts  as  a  programmatic  
confirmation
 
of
 
this
 
"Green
 
Bar."
 
By
 
identifying
 
the
 
crossing
 
event
 
on
 
Day
 
$T-1$
 
and
 
allowing
 
the
 
trader
 
to
 
act
 
on
 
Day
 
$T$,
 
we
 
are
 
essentially
 
waiting
 
for
 
the
 
bar
 
to
 
close
 
and
 
"paint"
 
the
 
signal.
 Crucially,  standard  trading  wisdom  (and  the  snippets)  suggests  placing  a  "Buy  Stop"  order  1  
tick
 
above
 
the
 
high
 
of
 
the
 
signal
 
candle.
 
Our
 
validation
 
logic
 
simplifies
 
this
 
to
 
"Enter
 
on
 
Open
 
of
 
Day
 
T,"
 
which
 
is
 
a
 
proxy
 
for
 
this
 
confirmation
 
entry.
 
5.2  The  200  SMA:  The  Institutional  Safety  Net  
The  requirement  Close  >  200  SMA  is  the  single  most  important  filter  in  this  system.  ●  Without  Filter:  The  WVF  is  mathematically  guaranteed  to  spike  during  crashes.  If  you  ran  
this
 
scan
 
during
 
the
 
2008
 
Financial
 
Crisis
 
without
 
the
 
SMA
 
filter,
 
it
 
would
 
have
 
signaled
 
"Buy"
 
on
 
Lehman
 
Brothers
 
all
 
the
 
way
 
down
 
to
 
zero.
 
The
 
WVF
 
measures
 
fear
,
 
and
 
fear
 
is
 
justified
 
in
 
a
 
collapse.
 ●  With  Filter:  By  requiring  the  price  to  be  above  the  200  SMA,  we  ensure  that  the  "fear"  is  
occurring
 
within
 
a
 
bullish
 
context.
 
This
 
suggests
 
the
 
fear
 
is
 
likely
 
an
 
overreaction
 
to
 
temporary
 
bad
 
news,
 
rather
 
than
 
a
 
structural
 
failure
 
of
 
the
 
company's
 
business
 
model.
 
This
 
filter
 
transforms
 
the
 
strategy
 
from
 
"Bottom
 
Fishing"
 
(high
 
risk)
 
to
 
"Buying
 
the
 
Dip"
 
(lower
 
risk).
 
5.3  Volatility  Squeezes  and  Expansions  
While  this  report  focuses  on  the  upper  band  (market  bottoms),  the  WVF  also  provides  insight  
into
 
market
 
tops.
 
When
 
the
 
WVF
 
is
 
exceptionally
 
low
 
(near
 
zero),
 
it
 
implies
 
the
 
price
 
is
 
grinding
 
upward
 
with
 
very
 
little
 
drawdown
 
from
 
the
 
highs.
 
This
 
is
 
often
 
called
 
a
 
"Volatility
 
Squeeze."
 Historically,  periods  of  extremely  low  WVF  are  often  followed  by  explosive  moves  (volatility  
expansion).
 
While
 
our
 
scan
 
looks
 
for
 
high
 
WVF
 
(the
 
explosion),
 
sophisticated
 
traders
 
watch
 
for
 
the
 
WVF
 
to
 
return
 
to
 
the
 
lower
 
band
 
to
 
signal
 
that
 
the
 
mean
 
reversion
 
move
 
is
 
exhausted
 
and
 
the
 
trend
 
has
 
normalized.3
 
--- Page 14 ---
Part  VI:  Validation  and  Performance  Metrics  
When  validating  this  strategy  using  the  "Time  Machine"  mode,  we  utilize  specific  metrics  to  
gauge
 
success.
 
6.1  The  5-Day  Time  Horizon  
The  choice  of  a  5-day  validation  period  is  not  arbitrary.  1.  Mean  Reversion  Half-Life:  Volatility  spikes  are  generally  mean-reverting  with  a  short  
half-life.
 
Panic
 
rarely
 
lasts
 
for
 
weeks
 
without
 
a
 
relief
 
bounce.
 2.  Weekly  Cycle:  Five  trading  days  represent  one  calendar  week.  This  aligns  with  the  
"swing
 
trading"
 
nature
 
of
 
the
 
strategy.
 3.  Signal  Decay:  If  the  trade  has  not  moved  in  your  favor  after  5  days,  the  signal  is  
considered
 
"stale."
 
The
 
immediate
 
imbalance
 
of
 
supply
 
and
 
demand
 
that
 
caused
 
the
 
VIX
 
spike
 
has
 
likely
 
been
 
absorbed,
 
and
 
the
 
asset
 
is
 
now
 
driven
 
by
 
other
 
factors.
 
6.2  Interpreting  Backtest  Results  
Table  1  below  illustrates  a  hypothetical  output  for  a  scan  run  on  October  27,  2023 ,  a  period  
known
 
for
 
a
 
market
 
low
 
before
 
a
 
significant
 
year-end
 
rally.
 
Ticker  Signal  Date  
Price  at  Signal  
WVF  Value  WVF  Upper  BB  
5-Day  Return  
AAPL  2023-10-26  166.89  14.50  14.10  +3.45%  
MSFT  2023-10-26  329.81  12.20  11.80  +4.12%  
NVDA  2023-10-26  403.20  18.90  18.10  +6.78%  
KO  2023-10-26  55.10  8.50  12.10  Filtered  (WVF  <  BB)  
Note:  In  this  hypothetical  scenario,  KO  (Coca-Cola)  might  be  in  an  uptrend,  but  its  volatility  
did
 
not
 
breach
 
the
 
upper
 
band,
 
so
 
it
 
is
 
filtered
 
out.
 
Key  Takeaway:  High  beta  stocks  (NVDA)  tend  to  show  higher  WVF  values  and  higher  5-day  
returns
 
during
 
bounces
 
compared
 
to
 
defensive
 
stocks
 
(AAPL,
 
MSFT).
 
The
 
scanner
 
captures
 
this
 
dynamic
 
effectively.
 
--- Page 15 ---
Part  VII:  Risks,  Limitations,  and  Advanced  
Optimizations
 7.1  Data  Integrity  and  Survivorship  Bias  
As  detailed  in  snippet  
14
,  sourcing  S&P  500  constituents  from  Wikipedia  introduces  
survivorship
 
bias.
 ●  The  Risk:  If  we  run  the  Time  Machine  for  2015  using  the  2024  list,  we  are  backtesting  
"winners."
 
We
 
are
 
effectively
 
asking,
 
"How
 
did
 
the
 
companies
 
that
 
became
 
successful
 
enough
 
to
 
be
 
in
 
the
 
S&P
 
500
 
today
 
perform
 
during
 
dips
 
in
 
2015?"
 ●  The  Reality:  We  miss  companies  that  were  in  the  S&P  500  in  2015  but  subsequently  
failed
 
or
 
were
 
delisted.
 ●  Mitigation:  For  a  production-grade  system,  one  must  purchase  a  "delisted  securities"  
database
 
and
 
a
 
"historical
 
index
 
constituent"
 
database
 
(e.g.,
 
from
 
Norgate
 
Data
 
or
 
QuantConnect).
 
For
 
educational
 
research
 
via
 
yfinance,
 
the
 
current
 
method
 
is
 
acceptable
 
provided
 
the
 
user
 
acknowledges
 
the
 
optimistic
 
bias.
 
7.2  Parameter  Sensitivity  (Overfitting)  
The  standard  settings  (22,  2.0,  20)  are  robust,  but  they  are  general.  ●  Optimization:  Different  sectors  may  require  different  sensitivities.  A  Utility  stock  might  
require
 
a
 
1.5
 
Standard
 
Deviation
 
setting
 
to
 
trigger,
 
while
 
a
 
Biotech
 
stock
 
might
 
need
 
2.5.
 ●  Recommendation:  Traders  should  perform  a  "Walk-Forward  Optimization,"  testing  
parameters
 
on
 
2018-2020
 
data
 
and
 
validating
 
on
 
2021-2023
 
data,
 
to
 
ensure
 
the
 
parameters
 
are
 
not
 
overfitted
 
to
 
a
 
specific
 
market
 
regime.
 
7.3  Stop-Loss  Implementation  
The  current  script  calculates  raw  returns.  In  practice,  risk  management  is  paramount.  
●  ATR  Trailing  Stop:  Snippet  
8
 suggests  using  an  Average  True  Range  (ATR)  trailing  stop.  A  
common
 
setting
 
is
 
$2
 
\times
 
ATR$
 
below
 
the
 
entry
 
price.
 ●  Hard  Stop:  Snippet  
5
 suggests  a  stop  "1  tick  below  the  low  of  the  signal  bar."  This  is  a  
tight
 
stop
 
that
 
offers
 
a
 
high
 
Risk:Reward
 
ratio
 
but
 
a
 
lower
 
win
 
rate
 
(higher
 
probability
 
of
 
being
 
stopped
 
out
 
on
 
noise).
 
Conclusion  
The  CM  Williams  Vix  Fix  strategy  represents  a  sophisticated  synthesis  of  statistical  analysis  
and
 
market
 
psychology.
 
By
 
quantifying
 
the
 
"fear"
 
inherent
 
in
 
price
 
drawdowns
 
and
 
filtering
 
these
 
signals
 
through
 
a
 
long-term
 
trend
 
filter
 
(SMA
 
200),
 
the
 
strategy
 
attempts
 
to
 
--- Page 16 ---
systematically  capture  mean  reversion  opportunities  in  high-quality  assets.  
The  Python  implementation  provided  herein  serves  as  a  robust  foundation  for  this  research.  It  
handles
 
the
 
complexities
 
of
 
bulk
 
data
 
acquisition,
 
liquidity
 
filtering,
 
and
 
look-ahead
 
bias
 
prevention.
 
While
 
limitations
 
regarding
 
data
 
sources
 
exist,
 
the
 
core
 
logic—buying
 
high-quality
 
assets
 
when
 
their
 
internal
 
volatility
 
reaches
 
statistical
 
extremes—remains
 
a
 
timeless
 
principle
 
of
 
quantitative
 
trading.
 
Disclaimer:  This  report  is  for  educational  purposes  only.  Financial  markets  are  inherently  risky.  
The
 
code
 
and
 
strategies
 
discussed
 
do
 
not
 
constitute
 
financial
 
advice.
 
Works  cited  
1.  Page  2  |  Macdcross  —  Indicators  and  Strategies  —  TradingView  —  India,  accessed  January  11,  2026,  https://in.tradingview.com/scripts/macdcross/page-2/ 2.  Williams  VIX  Fix  Strategy  (C#).  StockSharp,  accessed  January  11,  2026,  https://stocksharp.com/store/stocksharp.strategies.0454_williams_vix_fix/ 3.  Buy/Sell  Signals  for  CM_Williams_Vix_Fix  —  Indicator  by  Bekcoin  -  TradingView,  
accessed
 
January
 
11,
 
2026,
 https://in.tradingview.com/script/TbrWDdf5-buy-sell-signals-for-cm-williams-vix-fix/ 4.  Strona  18  |  Wskaźniki  Billa  Williamsa  —  Wskaźniki  i  Strategie,  accessed  January  11,  2026,  https://pl.tradingview.com/scripts/billwilliams/page-18/ 
5.
 
第
15
頁
|
 
"williams"
的
腳
本
搜
尋
結
果
—
 
TradingView,
 
accessed
 
January
 
11,
 
2026,
 https://tw.tradingview.com/scripts/search/williams/page-15/?script_type=indicators 6.  Williams  Vix  Fix  Bottoms  and  Tops  —  Indicator  by  theehoganator  -  TradingView,  
accessed
 
January
 
11,
 
2026,
 https://www.tradingview.com/script/wYbPyvTV-Williams-Vix-Fix-Bottoms-and-Tops/ 7.  VixFix  Dynamic  Volatility  Trading  System:  Multi-Indicator  Integration  with  Adaptive  
Trailing
 
Stop
 
Optimization
 
Strategy
 
|
 
by
 
FMZQuant
 
|
 
Medium,
 
accessed
 
January
 
11,
 
2026,
 https://medium.com/@FMZQuant/vixfix-dynamic-volatility-trading-system-multi-indicator-integration-with-adaptive-trailing-stop-6fbc29bc76c1 8.  How  to  download  market  data  with  yfinance  and  Python  -  PythonFinTech,  
accessed
 
January
 
11,
 
2026,
 https://pythonfintech.com/articles/how-to-download-market-data-yfinance-python/ 9.  ranaroussi/yfinance:  Download  market  data  from  Yahoo!  Finance's  API  -  GitHub,  accessed  January  11,  2026,  https://github.com/ranaroussi/yfinance 10.  S&P  500  Historical  Data  Analysis  Utilizing  yfinance  -  Kaggle,  accessed  January  11,  
2026,
 https://www.kaggle.com/code/swatsonds/s-p500-data-analysis-with-yfinance 11.  Get  the  S&P  500  tickers  list  -  python  -  Stack  Overflow,  accessed  January  11,  
--- Page 17 ---
2026,  https://stackoverflow.com/questions/44232578/get-the-sp-500-tickers-list 12.  How  to  Get  All  Stocks  from  the  S&P500  in  Python  |  by  Jachowski  -  InsiderFinance  
Wire,
 
accessed
 
January
 
11,
 
2026,
 https://wire.insiderfinance.io/how-to-get-all-stocks-from-the-s-p500-in-python-fbe5f9cb2b61 13.  Trying  to  build  a  database  of  S&P  500  companies  and  their  data  :  r/algotrading  -  
Reddit,
 
accessed
 
January
 
11,
 
2026,
 https://www.reddit.com/r/algotrading/comments/1moswib/trying_to_build_a_database_of_sp_500_companies/ 14.  Page  19  |  Scripts  Search  Results  for  "algo"  -  TradingView,  accessed  January  11,  2026,  https://www.tradingview.com/scripts/search/algo/page-19/ 15.  This  Indicator  PREDICTS  Market  Bottoms  with  HIGH  Accuracy  -  YouTube,  accessed  January  11,  2026,  https://www.youtube.com/watch?v=wbhudlPUNy4 
